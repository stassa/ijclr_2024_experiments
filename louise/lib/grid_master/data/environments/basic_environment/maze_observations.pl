:-module(maze_observations,[observation_labels/1
                           ,observations/1
                           ,lookaround/1
                           ,passability/2
                           ,observable_locations/2
                           ,lists_to_arrays/2
                           ,write_maze_files/2
                           ,controller_examples/2
                           ]).

:-use_module(lib(grid_master/src/map_display)).

/** <module> Analyse observations in a maze map.

*/


%!      observation_labels(-Looks) is det.
%
%       Generate all possible observation labels for any maze.
%
%       Looks is an array of atoms of the form PuPrPdPl where Pu, Pr, Pd
%       and Pl are in [p,u], for "passable" and "unpassable"
%       respecitvely, depending on the passability of the tile type
%       above, to the right, below and to the left of a location. All
%       possible atoms are generated, of which there are 15 for the four
%       tile types in this experiment.
%
%       Used to generate observations for examples to learn FSCs.
%
%       @tbd It isn't actually. Observations for FSCs are taken from
%       examples generated by a maze solver. But this is useful for
%       analysing and understanding the structure of mazes.
%
observation_labels(Ls):-
        observations(Os)
        ,findall(L
                ,(member(Os_i,Os)
                 ,atomic_list_concat(Os_i,'',L)
                 )
                ,Ls).


%!      observations(-Observations) is det.
%
%       Generate all possible Observations of passability in any maze.
%
%       Observations is a list of lists where each sublist is of the
%       form [U,R,D,L], standing for Up, Right, Down, and Left, each of
%       which is either "p" or "u", for a passable, or unpassable tile
%       in the specified location.
%
%       Observations models the observations of passable and unpassable
%       tiles made by an agent standing in some cell in a maze map and
%       "looking" in each of the four directions, observing the
%       passability or unpassability of tile types in each direction.
%
observations(Ls):-
        lookaround(Os)
        ,setof(Ps
              ,Os_i^Os^Ps^
               (member(Os_i,Os)
               ,legal(Os_i)
               ,passability(Os_i,Ps)
               )
              ,Ls).


%!      lookaround(-Looks) is det.
%
%       Generate all possible look-around lists of tiles in a maze.
%
%       Looks is a list of lists where each sublist is of the form
%       [U,R,D,L], standing for Up, Right, Down and Left, each of which
%       is a constant denoting a tile type, typically [s,e,f,w] for
%       start, end, floor and wall tiles, respectively.
%
%       Looks models the observations of tile types of an agent standing
%       in some cell in a maze map and "looking" in each of the four
%       directions, observing the tile types in each direction.
%
lookaround(Os):-
        setof([O1,O2,O3,O4]
             ,O1^O2^O3^O4^
              (maplist(member
                      ,[O1,O2,O3,O4]
                      ,[[s,f,w,e],[s,f,w,e],[s,f,w,e],[s,f,w,e]])
              )
             ,Os).


%!      passability(+Observations,-Passability) is det.
%
%       Construct a Passability four-tuple from a list of Observations.
%
%       Observations is a list of observations of tile types, as
%       returned by lookaround/1.
%
%       Passability is a list of lists, where each sublist is of the
%       form [U,R,D,L], standing for Up, Right, Down, and Left, each of
%       which is either "p" or "u". Passability is formed such
%       that for each i'th observations list in Observations,
%       the k'th element in that list is p if the tile in the k'th
%       element of the i'th sublist of Observations is a passable tile,
%       and u if that tile is an unpassable tile.
%
%       In other words, this predicate maps observations of tile types,
%       to lists of observations of passability, all from the
%       view-point of an agent "standing" in some location in a maze and
%       "looking" around in the four cardinal directions.
%
passability(Os,Ps):-
        findall(P
               ,(member(O,Os)
                ,passable(O,P)
                )
               ,Ps).


%!      passable(+Observation,-Passability) is det.
%
%       Passability of an observed tile.
%
passable(O,p):-
        grid_master_configuration:passable(O)
        ,!.
passable(_O,u).


%!      legal(+Observations) is det.
%
%       True if a four-tuple of observed tiles is legal.
%
legal([O1,O2,O3,O4]):-
        \+ blocked([O1,O2,O3,O4])
        ,\+ multiple_starts([O1,O2,O3,O4])
        ,\+ multiple_exits([O1,O2,O3,O4]).

%!      blocked(?Observations) is semidet.
%
%       A four-tuple of Observations indicating a blocked tile.
%
%       Blocked as in there are unpassable tiles all around it.
%
blocked([O,O,O,O]).

%!      multiple_starts(+Observations) is det.
%
%       A four-tuple of Observations with multiple start tiles.
%
multiple_starts(Os):-
        multiples(s,Os).

%!      multiple_exits(+Observations) is det.
%
%       A four-tuple of Observations with multiple exit tiles.
%
multiple_exits(Os):-
        multiples(e,Os).

%!      multiples(+Observation,+Observations) is det.
%
%       True when an Observation is not unique in Observations.
%
%       @tbd Is this right? What if Observations is not in Observations
%       at all?
%
multiples(O,[O1,O2,O3,O4]):-
        findall(O
               ,member(O,[O1,O2,O3,O4])
               ,Ts)
        ,length(Ts,N)
        ,N > 1.



%!      observable_locations(+Dimensions,-Locations).
%
%       Generate all observable Locations in a maze map.
%
%       Dimensions is a pair W-H, the width and height of the generated
%       Grid. This should be 3-3, since we're only interested in the
%       observations of tiles just one cell away from the current
%       location of the agent, but it's possible we might want to extend
%       this later.
%
%       Locations is a list of W x H grids with passable, unpassable and
%       unobservable tiles, from the point of view of an agent standing
%       in the central cell in the grid.
%
%       Example call:
%       ==
%       ?- _M = maze_observations
%       ,_Ds = 3-3
%       ,_M:observable_locations(_Ds,_Ls)
%       ,_M:lists_to_arrays(_Ls,_As)
%       ,member(_Map,_As)
%       ,map_display:print_map(tiles,_Ds,_Map).
%
%       x □ x
%       □ □ □
%       x □ x
%       true ;
%       x □ x
%       ■ □ □
%       x □ x
%       true ;
%       x □ x
%       □ □ □
%       x ■ x
%       true ;
%       x □ x
%       ■ □ □
%       x ■ x
%       % etc.
%       ==
%
%       In the example above, passable tiles are marked with □,
%       unpassable tiles with ■ and unobservable tiles with x.
%
observable_locations(Ds,LS):-
        observations(Os)
        ,findall(Ls
                ,(member(Os_i,Os)
                 ,observations_grid(Os_i,Ds,Ls))
                ,LS).


%!      observations_grid(+Observations,+Dimensions,-Grid) is det.
%
%       Create one Grid of look-around Observations.
%
%       Observations is a list of passability observations, as generated
%       by observations/1.
%
%       Dimensions is a pair W-H, the width and height of the generated
%       Grid. This should be 3-3, since we're only interested in the
%       observations of tiles just one cell away from the current
%       location of the agent, but it's possible we might want to extend
%       this later.
%
%       Grid is a list-of-lists representing the grid of observable and
%       unobservable passability of the tiles representing the
%       observations of an agent standing in the middle of the grid.
%       Kind of inductively defined, then. Unobservable tiles are marked
%       with a different symbol than passable or unpassable tiles for
%       clarity.
%
%       See observable_locations/2 for an example of output (that
%       predicate generates all possible observable grids by calling
%       this predicate nondeterministically).
%
observations_grid(Os,W-H,Ms):-
        maplist(dec,[W,H],[Max_x,Max_y])
        ,findall(Ts
               ,(between(0,Max_y,Y)
                ,findall(T,
                         (between(0,Max_x,X)
                         ,cell(Os,X/Y,C)
                         ,cell_tile(C,T)
                         )
                        ,Ts)
                )
               ,Ms).

%!      dec(X,Y) is det.
%
%       Decrement an integer X.
%
%       Helper arithmetic predicate to be passed to maplist/2 to
%       decrement coordinates.
%
%       @tbd Copied from map_display.pl because I can't access it
%       otherwise from this module. Why?
%
dec(X,X_):- X_ is X - 1.

%cell([O1,O2,O3,O4],X/Y,T).

%!      cell(?Observation,?Coords,?Cell) is semidet.
%
%       Mapping between maze cell observations and tile types.
%
%       Observation is a list of observations as generated by
%       observations/1, via observations_grid/2. Each element of
%       Observations is either "p" or "u" for "passable" and
%       "unpassable".
%
%       Coords is a pair X/Y, the coordinates of a tile in a grid
%       in the process of being constructed by observations_grid/3.
%
%       Cell is the passability, or observability, of the cell in the
%       location indicated by coords. If the cell is observable, it is
%       marked as passable or unpassable, by "p" and "u", respectively.
%       If the cell is not observable it is marked with "x" instead.
%
%       The table ish below shows the locations in a grid that are
%       denoted by Coords and their meaning. The coordinates of the
%       central location, >1/1< are the coordinates of the assumed
%       position of an agent observing surrounding locations.
%       Coordinates of bservable locations are marked with [X/Y].
%       Unobservable locations are not marked. The agent's location is
%       always observable and passable. Coordinates in the diagonals are
%       not, currently, observable.
%
%        0/0  [1/0]  2/0
%       [0/1] >1/1< [2/1]
%        0/2  [1/2]  2/2
%
cell([O1,_O2,_O3,_O4],1/0,O1):- !.
cell([_O1,O2,_O3,_O4],2/1,O2):- !.
cell([_O1,_O2,O3,_O4],1/2,O3):- !.
cell([_O1,_O2,_O3,O4],0/1,O4):- !.
cell([_O1,_O2,_O3,_O4],1/1,p):- !.
cell([_O1,_O2,_O3,_O4],_X/_Y,x).


%!      cell_tile(?Observable,?Tile) is semidet.
%
%       Mapping between observability/passability and Tile type.
%
%       Used by observation_grid/3 to mark locations in a grid as
%       observable or not, and then passable or not.
%
%       Also see: cell/3.
%
cell_tile(p,f).
cell_tile(u,w).
cell_tile(x,x).



%!      lists_to_arrays(+Lists,-Arrays) is det.
%
%       Convert a list of nested lists into row-major order Arrays.
%
lists_to_arrays(Ls,As):-
        findall(A_i
               ,(member(Ls_i,Ls)
                ,lists_to_array(Ls_i,A_i)
                )
               ,As).


%!      lists_to_array(+Lists,-Array) is det.
%
%       Convert between nested list and Array map notations.
%
lists_to_array(Ls,A):-
        flatten(Ls,Ls_f)
        ,A =.. [c|Ls_f].



%!      write_maze_files(+Name,+Directory) is det.
%
%       Write maze files to a Directory.
%
%       Name is an atom, the base name of each file to be printed. An
%       indexing suffix will be addded to that.
%
%       Directory is the directory where each map file is to be printed.
%
%       Note that for this to work, the grid_master_configuration option
%       theme/1 must be set to 'text', so this prints out text to be
%       read back in by grid master as a map.
%
%       Example query:
%       ==
%       _Name = pge
%       ,_Dir = data(drafts/grid_master/data/maps)
%       ,maze_observations:write_maze_files(_Name,_Dir).
%       ==
%
write_maze_files(N,Dir):-
        Ds = 3-3
        ,observable_locations(Ds,Ls)
        ,lists_to_arrays(Ls,As)
        ,expand_file_search_path(Dir,P)
        ,forall(nth1(I,As,Map)
               ,(atomic_list_concat([N,I],'_',Id)
                ,directory_file_path(P,Id,Bn)
                ,atom_concat(Bn,'.map',F)
                ,write_map_file(F,map(Id,3-3,Map))
                )
               ).



%!      controller_examples(+Name,-Examples) is det.
%
%       Generate Examples to learn a controller.
%
%       Needs the mazes generated with observable_locations/2 to be
%       loaded as primitives (i.e. with maps and actions and all).
%
controller_examples(N,Es):-
        configuration:experiment_file(_,M)
        ,findall(Id
               ,(between(1,15,I)
                ,atomic_list_concat([N,I],'_',Id)
                )
               ,Ids)
        ,findall(E
               ,(member(Id,Ids)
                ,member(Q0,[q0,q1,q2,q3])
                ,M:solver_test_instance(s/2,E,[Id,1,1,1/1,_,_,_,Q0|_Ss])
                ,call(M:E)
                )
                ,Es).
